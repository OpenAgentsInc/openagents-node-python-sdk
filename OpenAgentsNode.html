<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>openagents.OpenAgentsNode API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>openagents.OpenAgentsNode</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import grpc
from openagents_grpc_proto import rpc_pb2_grpc
from openagents_grpc_proto import rpc_pb2
import time
import os
import traceback
import asyncio
from .JobRunner import JobRunner
from .NodeConfig import NodeConfig
from .Logger import Logger
from typing import Union
from .JobContext import JobContext
import json
class HeaderAdderInterceptor(
    grpc.aio.ClientInterceptor     
):
    &#34;&#34;&#34;
    An interceptor for GRPC that adds headers to outgoing requests.
    &#34;&#34;&#34;
    def __init__(self, headers):
        self._headers = headers

  

    async def _intercept(self, continuation, client_call_details, request_or_iterator):
        metadata = client_call_details.metadata
        if not metadata:
            metadata = grpc.aio.Metadata()
        for header in self._headers:
            metadata.add(header[0], header[1])
        new_client_call_details = client_call_details._replace(metadata=metadata)
        response = await continuation(new_client_call_details, request_or_iterator)
        return response

class HeaderAdderInterceptor0(grpc.aio.UnaryStreamClientInterceptor,HeaderAdderInterceptor):
    async def intercept_unary_stream(self, continuation, client_call_details, request):
        return await self._intercept(continuation, client_call_details, request)

class HeaderAdderInterceptor1(grpc.aio.StreamUnaryClientInterceptor,HeaderAdderInterceptor):
    async def intercept_stream_unary(self, continuation, client_call_details, request_iterator):
        return await self._intercept(continuation, client_call_details, request_iterator)
    
class HeaderAdderInterceptor2(grpc.aio.StreamStreamClientInterceptor,HeaderAdderInterceptor):
    async def intercept_stream_stream(self, continuation, client_call_details, request_iterator):
        return await self._intercept(continuation, client_call_details, request_iterator)

class HeaderAdderInterceptor3(grpc.aio.UnaryUnaryClientInterceptor,HeaderAdderInterceptor):
    async def intercept_unary_unary(self, continuation, client_call_details, request):
        return await self._intercept(continuation, client_call_details, request)
 

class OpenAgentsNode:
    &#34;&#34;&#34;
    An OpenAgents node that can run jobs.
    The node can be configured with the following environment variables:
    - NODE_NAME: The name of the node. Defaults to &#34;OpenAgentsNode&#34;.
    - NODE_ICON: The icon of the node. Defaults to &#34;&#34;.
    - NODE_VERSION: The version of the node. Defaults to &#34;0.0.1&#34;.
    - NODE_DESCRIPTION: The description of the node. Defaults to &#34;&#34;.
    - POOL_ADDRESS: The address of the pool. Defaults to &#34;
    - POOL_PORT: The port of the pool. Defaults to 5000.
    - POOL_SSL: Whether to use SSL for the pool. Defaults to False.
    - NODE_TPS: The ticks per second of the node main loop. Defaults to 10.
    - NODE_TOKEN: The token of the node. Defaults to None.
    &#34;&#34;&#34;
  
    def __init__(self, config: NodeConfig):
        self.meta = config.getMeta()
            
        self.nextNodeAnnounce = 0        
        self.channel = None
        self.rpcClient = None
        self.registeredRunners=[]
        self.poolAddress = None
        self.poolPort = None
        self.lockedJobs = []
        self.isLooping = False
        self.logger = None
        self.loopInterval = 100
        
    
        self.nodeName = self.meta[&#34;name&#34;]
        self.nodeIcon =  self.meta[&#34;picture&#34;]
        self.nodeVersion =  self.meta[&#34;version&#34;]
        self.nodeDescription =  self.meta[&#34;description&#34;]

        self.channel = None
        self.rpcClient = None
        self.logger = Logger(self.nodeName,self.nodeVersion)
        self.logger.info(&#34;Starting &#34;+self.nodeName+&#34; v&#34;+self.nodeVersion)

    def getMeta(self):
        return self.meta

    def registerRunner(self, runner:JobRunner) -&gt; None:
        &#34;&#34;&#34;
        Register a runner to the node.
        Args:
            runner (JobRunner): The runner to register.
        &#34;&#34;&#34;
        self.registeredRunners.append({
            &#34;runner&#34;: runner,
            &#34;nextAnnouncementTimestamp&#34;: 0    
        })

    def getLogger(self):
        &#34;&#34;&#34;
        Get the active logger for the node.
        &#34;&#34;&#34;
        return self.logger        

    def _getClient(self): 
        &#34;&#34;&#34;
        Get or create a GRPC client for the node.
        &#34;&#34;&#34;
        if self.channel is None or self.channel._channel.check_connectivity_state(True)  == grpc.ChannelConnectivity.SHUTDOWN:
            if self.channel is not None:
                try:
                    self.getLogger().info(&#34;Closing channel&#34;)
                    self.channel.close()
                except Exception as e:
                    self.getLogger().error(&#34;Error closing channel &#34;+str(e))
            self.getLogger().info(&#34;Connect to &#34;+self.poolAddress+&#34;:&#34;+str(self.poolPort)+&#34; with ssl &#34;+str(self.poolSsl))
            
            options=[
                # 20 MB
                (&#39;grpc.max_send_message_length&#39;, 1024*1024*20),
                (&#39;grpc.max_receive_message_length&#39;, 1024*1024*20)
            ]

            interceptors=None
            nodeToken = os.getenv(&#39;NODE_TOKEN&#39;, None)
            if nodeToken:
                metadata=[
                    (&#34;authorization&#34;, str(nodeToken))
                ]
                if interceptors is None: interceptors=[]
                interceptors.append(HeaderAdderInterceptor0(metadata))
                interceptors.append(HeaderAdderInterceptor1(metadata))
                interceptors.append(HeaderAdderInterceptor2(metadata))
                interceptors.append(HeaderAdderInterceptor3(metadata))
                

            if self.poolSsl:
                self.channel = grpc.aio.secure_channel(self.poolAddress+&#34;:&#34;+str(self.poolPort), grpc.ssl_channel_credentials(),options,interceptors=interceptors)
            else:
                self.channel = grpc.aio.insecure_channel(self.poolAddress+&#34;:&#34;+str(self.poolPort),options,interceptors=interceptors)
            
            self.rpcClient = rpc_pb2_grpc.PoolConnectorStub(self.channel)
            

        return self.rpcClient

    async def _logToJob(self, message:str, jobId:str=None):
        &#34;&#34;&#34;
        Log a message to a job.
        Args:
            message (str): The message to log.
            jobId (str): The ID of the job to log to.
        &#34;&#34;&#34;
        try:
            await self._getClient().logForJob(rpc_pb2.RpcJobLog(jobId=jobId, log=message)) 
        except Exception as e:
            print(&#34;Error logging to job &#34;+str(e))

    def _log(self,message:str, jobId:str=None):
        &#34;&#34;&#34;
        Log a message to the network.
        Args:
            message (str): The message to log.
            jobId (str): The ID of the job to log to.
        &#34;&#34;&#34;
        if jobId: 
            asyncio.create_task(self._logToJob(message, jobId))
    
    async def _acceptJob(self, jobId:str):
        &#34;&#34;&#34;
        Accept a job.
        Args:
            jobId (str): The ID of the job to accept.
        &#34;&#34;&#34;
        await self._getClient().acceptJob(rpc_pb2.RpcAcceptJob(jobId=jobId))

    async def _executePendingJobForRunner(self , runner:JobRunner):
        &#34;&#34;&#34;
        Execute all pending jobs for a runner.
        Args:
            runner (JobRunner): The runner to execute the job.
        &#34;&#34;&#34;
        if len([x for x in self.registeredRunners if x[&#34;runner&#34;]==runner])==0:
            del self.runnerTasks[runner]
            return
        
        try:
            if not runner.initialized:
                runner.initialized=True
                await runner.init(self)
            client = self._getClient()
            jobs=[]
            filter = runner.getFilter()
            self.lockedJobs = [x for x in self.lockedJobs if time.time()-x[1] &lt; 60]
            jobs.extend((await client.getPendingJobs(rpc_pb2.RpcGetPendingJobs(
                filterByRunOn =  filter[&#34;filterByRunOn&#34;] if &#34;filterByRunOn&#34; in filter else None,
                filterByCustomer = filter[&#34;filterByCustomer&#34;] if &#34;filterByCustomer&#34; in filter else None,
                filterByDescription = filter[&#34;filterByDescription&#34;] if &#34;filterByDescription&#34; in filter else None,
                filterById = filter[&#34;filterById&#34;] if &#34;filterById&#34; in filter else None,
                filterByKind  = filter[&#34;filterByKind&#34;] if &#34;filterByKind&#34; in filter else None,
                wait=60000,
                # exclude failed jobs
                excludeId = [x[0] for x in self.lockedJobs]
            ))).jobs)    

            if len(jobs)&gt;0 : self.getLogger().log(str(len(jobs))+&#34; pending jobs for &#34;+runner.__class__.__name__)
            else : self.getLogger().finer(&#34;No pending jobs for &#34;+runner.__class__.__name__)
            
            for job in jobs:              
                wasAccepted=False
                t=time.time()   
                ctx = JobContext(self,runner,job)
                try:
                    client = self._getClient() # Refresh client connection if needed
                    if not await runner.canRun(ctx):
                        await ctx.close()
                        continue
                    self.lockedJobs.append([job.id, time.time()])
                    await self._acceptJob(job.id)
                    wasAccepted = True


                    
                    ctx.getLogger().info(&#34;Job started on node &#34;+self.nodeName)  
                    
                    await runner.preRun(ctx)
                    async def task():
                        try:
                            output=await runner.run(ctx) 
                            await runner.postRun(ctx)                  
                            ctx.getLogger().info(&#34;Job completed in &#34;+str(time.time()-t)+&#34; seconds on node &#34;+self.nodeName, job.id)                
                            await client.completeJob(rpc_pb2.RpcJobOutput(jobId=job.id, output=output))
                        except Exception as e:
                            ctx.getLogger().error(&#34;Job failed in &#34;+str(time.time()-t)+&#34; seconds on node &#34;+self.nodeName+&#34; with error &#34;+str(e), job.id)
                            if wasAccepted:
                                await client.cancelJob(rpc_pb2.RpcCancelJob(jobId=job.id, reason=str(e)))
                            traceback.print_exc()
                        await ctx.close()
                    if not runner.isRunInParallel():
                        await task()
                    else:
                        asyncio.create_task(task())
                except Exception as e:
                    ctx.getLogger().error(&#34;Job failed in &#34;+str(time.time()-t)+&#34; seconds on node &#34;+self.nodeName+&#34; with error &#34;+str(e), job.id)
                    await ctx.close()
                    if wasAccepted:
                        await client.cancelJob(rpc_pb2.RpcCancelJob(jobId=job.id, reason=str(e)))
                    traceback.print_exc()

        except Exception as e:
            traceback.print_exc()
            self.getLogger().error(&#34;Error executing runner &#34;+str(e))
            await asyncio.sleep(5000.0/1000.0)
        self.runnerTasks[runner]=asyncio.create_task(self._executePendingJobForRunner(runner))

 
    runnerTasks={}
    async def _executePendingJob(self ):
        &#34;&#34;&#34;
        Execute all pending jobs for all runners.
        &#34;&#34;&#34;
        for reg in self.registeredRunners:
            try:
                runner = reg[&#34;runner&#34;]
                if not runner in self.runnerTasks:
                    self.runnerTasks[runner]=asyncio.create_task(self._executePendingJobForRunner(runner))
            except Exception as e:
                self.getLogger().log(&#34;Error executing pending job &#34;+str(e), None)


    async def reannounce(self):    
        &#34;&#34;&#34;
        Reannounce the node and all templates.
        &#34;&#34;&#34;
        # Announce node
        try:
            time_ms=int(time.time()*1000)
            if time_ms &gt;= self.nextNodeAnnounce:
                try:
                    client = self._getClient()
                    res=await client.announceNode(rpc_pb2.RpcAnnounceNodeRequest(
                        iconUrl = self.nodeIcon,
                        name = self.nodeName,
                        description = self.nodeDescription,
                    ))
                    self.nextNodeAnnounce = int(time.time()*1000) + res.refreshInterval
                    self.getLogger().log(&#34;Node announced, next announcement in &#34;+str(res.refreshInterval)+&#34; ms&#34;)
                except Exception as e:
                    self.getLogger().error(&#34;Error announcing node &#34;+ str(e), None)
                    self.nextNodeAnnounce = int(time.time()*1000) + 5000

            for reg in self.registeredRunners:
                try:
                    if time_ms &gt;=  reg[&#34;nextAnnouncementTimestamp&#34;]:
                        client = self._getClient()
                        res = await client.announceEventTemplate(rpc_pb2.RpcAnnounceTemplateRequest(
                            meta=json.dumps(reg[&#34;runner&#34;].getMeta()),
                            template=reg[&#34;runner&#34;].getTemplate(),
                            sockets=json.dumps(reg[&#34;runner&#34;].getSockets())
                        ))
                        reg[&#34;nextAnnouncementTimestamp&#34;] = int(time.time()*1000) + res.refreshInterval
                        self.getLogger().log(&#34;Template announced, next announcement in &#34;+str(res.refreshInterval)+&#34; ms&#34;)
                except Exception as e:
                    self.getLogger().error(&#34;Error announcing template &#34;+ str(e), None)
                    reg[&#34;nextAnnouncementTimestamp&#34;] = int(time.time()*1000) + 5000
        except Exception as e:
            self.getLogger().error(&#34;Error reannouncing &#34;+str(e), None)
        await asyncio.sleep(5000.0/1000.0)
        asyncio.create_task(self.reannounce())
  
    async def _loop(self):
        &#34;&#34;&#34;
        The main loop of the node.
        &#34;&#34;&#34;
        promises = [reg[&#34;runner&#34;].loop(self) for reg in self.registeredRunners]
        await asyncio.gather(*promises)
        self.isLooping = False
        await asyncio.sleep(self.loopInterval/1000.0)
        asyncio.create_task(self._loop())
        

    async def _run(self, poolAddress=None, poolPort=None, poolSsl=False):
        &#34;&#34;&#34;
        Internal method to run the node.
        Should not be called, use start() instead.
        &#34;&#34;&#34;
        await asyncio.sleep(5000.0/1000.0)
        self.poolAddress = poolAddress or os.getenv(&#39;POOL_ADDRESS&#39;, &#34;playground.openagents.com&#34;)
        self.poolPort = poolPort or int(os.getenv(&#39;POOL_PORT&#39;, &#34;6021&#34;))
        self.poolSsl = poolSsl or os.getenv(&#39;POOL_SSL&#39;, &#34;true&#34;)== &#34;true&#34;
        self.loopInterval = 1000.0/int(os.getenv(&#39;NODE_TPS&#39;, &#34;10&#34;))

        await self._loop()
        await self.reannounce()
        while True:
            await self._executePendingJob()
            await asyncio.sleep(1000.0/1000.0)
        
    def start(self, poolAddress:str=None, poolPort:str=None):
        &#34;&#34;&#34;
        Start the node in an asyncio event loop.
        Args:
            poolAddress (str): The address of the pool. Defaults to
                the environment variable POOL_ADDRESS.
            poolPort (int): The port of the pool. Defaults to the
                environment variable POOL_PORT.
        &#34;&#34;&#34;
        asyncio.run(self._run(poolAddress, poolPort))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="openagents.OpenAgentsNode.HeaderAdderInterceptor"><code class="flex name class">
<span>class <span class="ident">HeaderAdderInterceptor</span></span>
<span>(</span><span>headers)</span>
</code></dt>
<dd>
<div class="desc"><p>An interceptor for GRPC that adds headers to outgoing requests.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HeaderAdderInterceptor(
    grpc.aio.ClientInterceptor     
):
    &#34;&#34;&#34;
    An interceptor for GRPC that adds headers to outgoing requests.
    &#34;&#34;&#34;
    def __init__(self, headers):
        self._headers = headers

  

    async def _intercept(self, continuation, client_call_details, request_or_iterator):
        metadata = client_call_details.metadata
        if not metadata:
            metadata = grpc.aio.Metadata()
        for header in self._headers:
            metadata.add(header[0], header[1])
        new_client_call_details = client_call_details._replace(metadata=metadata)
        response = await continuation(new_client_call_details, request_or_iterator)
        return response</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>grpc.aio._interceptor.ClientInterceptor</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="openagents.OpenAgentsNode.HeaderAdderInterceptor0" href="#openagents.OpenAgentsNode.HeaderAdderInterceptor0">HeaderAdderInterceptor0</a></li>
<li><a title="openagents.OpenAgentsNode.HeaderAdderInterceptor1" href="#openagents.OpenAgentsNode.HeaderAdderInterceptor1">HeaderAdderInterceptor1</a></li>
<li><a title="openagents.OpenAgentsNode.HeaderAdderInterceptor2" href="#openagents.OpenAgentsNode.HeaderAdderInterceptor2">HeaderAdderInterceptor2</a></li>
<li><a title="openagents.OpenAgentsNode.HeaderAdderInterceptor3" href="#openagents.OpenAgentsNode.HeaderAdderInterceptor3">HeaderAdderInterceptor3</a></li>
</ul>
</dd>
<dt id="openagents.OpenAgentsNode.HeaderAdderInterceptor0"><code class="flex name class">
<span>class <span class="ident">HeaderAdderInterceptor0</span></span>
<span>(</span><span>headers)</span>
</code></dt>
<dd>
<div class="desc"><p>Affords intercepting unary-stream invocations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HeaderAdderInterceptor0(grpc.aio.UnaryStreamClientInterceptor,HeaderAdderInterceptor):
    async def intercept_unary_stream(self, continuation, client_call_details, request):
        return await self._intercept(continuation, client_call_details, request)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>grpc.aio._interceptor.UnaryStreamClientInterceptor</li>
<li><a title="openagents.OpenAgentsNode.HeaderAdderInterceptor" href="#openagents.OpenAgentsNode.HeaderAdderInterceptor">HeaderAdderInterceptor</a></li>
<li>grpc.aio._interceptor.ClientInterceptor</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openagents.OpenAgentsNode.HeaderAdderInterceptor0.intercept_unary_stream"><code class="name flex">
<span>async def <span class="ident">intercept_unary_stream</span></span>(<span>self, continuation, client_call_details, request)</span>
</code></dt>
<dd>
<div class="desc"><p>Intercepts a unary-stream invocation asynchronously.</p>
<p>The function could return the call object or an asynchronous
iterator, in case of being an asyncrhonous iterator this will
become the source of the reads done by the caller.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>continuation</code></strong></dt>
<dd>A coroutine that proceeds with the invocation by
executing the next interceptor in the chain or invoking the
actual RPC on the underlying Channel. It is the interceptor's
responsibility to call it if it decides to move the RPC forward.
The interceptor can use
<code>call = await continuation(client_call_details, request)</code>
to continue with the RPC. <code>continuation</code> returns the call to the
RPC.</dd>
<dt><strong><code>client_call_details</code></strong></dt>
<dd>A ClientCallDetails object describing the
outgoing RPC.</dd>
<dt><strong><code>request</code></strong></dt>
<dd>The request value for the RPC.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The RPC Call or an asynchronous iterator.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>AioRpcError</code></dt>
<dd>Indicating that the RPC terminated with non-OK status.</dd>
<dt><code>asyncio.CancelledError</code></dt>
<dd>Indicating that the RPC was canceled.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def intercept_unary_stream(self, continuation, client_call_details, request):
    return await self._intercept(continuation, client_call_details, request)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="openagents.OpenAgentsNode.HeaderAdderInterceptor1"><code class="flex name class">
<span>class <span class="ident">HeaderAdderInterceptor1</span></span>
<span>(</span><span>headers)</span>
</code></dt>
<dd>
<div class="desc"><p>Affords intercepting stream-unary invocations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HeaderAdderInterceptor1(grpc.aio.StreamUnaryClientInterceptor,HeaderAdderInterceptor):
    async def intercept_stream_unary(self, continuation, client_call_details, request_iterator):
        return await self._intercept(continuation, client_call_details, request_iterator)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>grpc.aio._interceptor.StreamUnaryClientInterceptor</li>
<li><a title="openagents.OpenAgentsNode.HeaderAdderInterceptor" href="#openagents.OpenAgentsNode.HeaderAdderInterceptor">HeaderAdderInterceptor</a></li>
<li>grpc.aio._interceptor.ClientInterceptor</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openagents.OpenAgentsNode.HeaderAdderInterceptor1.intercept_stream_unary"><code class="name flex">
<span>async def <span class="ident">intercept_stream_unary</span></span>(<span>self, continuation, client_call_details, request_iterator)</span>
</code></dt>
<dd>
<div class="desc"><p>Intercepts a stream-unary invocation asynchronously.</p>
<p>Within the interceptor the usage of the call methods like <code>write</code> or
even awaiting the call should be done carefully, since the caller
could be expecting an untouched call, for example for start writing
messages to it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>continuation</code></strong></dt>
<dd>A coroutine that proceeds with the invocation by
executing the next interceptor in the chain or invoking the
actual RPC on the underlying Channel. It is the interceptor's
responsibility to call it if it decides to move the RPC forward.
The interceptor can use
<code>call = await continuation(client_call_details, request_iterator)</code>
to continue with the RPC. <code>continuation</code> returns the call to the
RPC.</dd>
<dt><strong><code>client_call_details</code></strong></dt>
<dd>A ClientCallDetails object describing the
outgoing RPC.</dd>
<dt><strong><code>request_iterator</code></strong></dt>
<dd>The request iterator that will produce requests
for the RPC.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The RPC Call.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>AioRpcError</code></dt>
<dd>Indicating that the RPC terminated with non-OK status.</dd>
<dt><code>asyncio.CancelledError</code></dt>
<dd>Indicating that the RPC was canceled.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def intercept_stream_unary(self, continuation, client_call_details, request_iterator):
    return await self._intercept(continuation, client_call_details, request_iterator)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="openagents.OpenAgentsNode.HeaderAdderInterceptor2"><code class="flex name class">
<span>class <span class="ident">HeaderAdderInterceptor2</span></span>
<span>(</span><span>headers)</span>
</code></dt>
<dd>
<div class="desc"><p>Affords intercepting stream-stream invocations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HeaderAdderInterceptor2(grpc.aio.StreamStreamClientInterceptor,HeaderAdderInterceptor):
    async def intercept_stream_stream(self, continuation, client_call_details, request_iterator):
        return await self._intercept(continuation, client_call_details, request_iterator)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>grpc.aio._interceptor.StreamStreamClientInterceptor</li>
<li><a title="openagents.OpenAgentsNode.HeaderAdderInterceptor" href="#openagents.OpenAgentsNode.HeaderAdderInterceptor">HeaderAdderInterceptor</a></li>
<li>grpc.aio._interceptor.ClientInterceptor</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openagents.OpenAgentsNode.HeaderAdderInterceptor2.intercept_stream_stream"><code class="name flex">
<span>async def <span class="ident">intercept_stream_stream</span></span>(<span>self, continuation, client_call_details, request_iterator)</span>
</code></dt>
<dd>
<div class="desc"><p>Intercepts a stream-stream invocation asynchronously.</p>
<p>Within the interceptor the usage of the call methods like <code>write</code> or
even awaiting the call should be done carefully, since the caller
could be expecting an untouched call, for example for start writing
messages to it.</p>
<p>The function could return the call object or an asynchronous
iterator, in case of being an asyncrhonous iterator this will
become the source of the reads done by the caller.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>continuation</code></strong></dt>
<dd>A coroutine that proceeds with the invocation by
executing the next interceptor in the chain or invoking the
actual RPC on the underlying Channel. It is the interceptor's
responsibility to call it if it decides to move the RPC forward.
The interceptor can use
<code>call = await continuation(client_call_details, request_iterator)</code>
to continue with the RPC. <code>continuation</code> returns the call to the
RPC.</dd>
<dt><strong><code>client_call_details</code></strong></dt>
<dd>A ClientCallDetails object describing the
outgoing RPC.</dd>
<dt><strong><code>request_iterator</code></strong></dt>
<dd>The request iterator that will produce requests
for the RPC.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The RPC Call or an asynchronous iterator.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>AioRpcError</code></dt>
<dd>Indicating that the RPC terminated with non-OK status.</dd>
<dt><code>asyncio.CancelledError</code></dt>
<dd>Indicating that the RPC was canceled.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def intercept_stream_stream(self, continuation, client_call_details, request_iterator):
    return await self._intercept(continuation, client_call_details, request_iterator)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="openagents.OpenAgentsNode.HeaderAdderInterceptor3"><code class="flex name class">
<span>class <span class="ident">HeaderAdderInterceptor3</span></span>
<span>(</span><span>headers)</span>
</code></dt>
<dd>
<div class="desc"><p>Affords intercepting unary-unary invocations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HeaderAdderInterceptor3(grpc.aio.UnaryUnaryClientInterceptor,HeaderAdderInterceptor):
    async def intercept_unary_unary(self, continuation, client_call_details, request):
        return await self._intercept(continuation, client_call_details, request)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>grpc.aio._interceptor.UnaryUnaryClientInterceptor</li>
<li><a title="openagents.OpenAgentsNode.HeaderAdderInterceptor" href="#openagents.OpenAgentsNode.HeaderAdderInterceptor">HeaderAdderInterceptor</a></li>
<li>grpc.aio._interceptor.ClientInterceptor</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openagents.OpenAgentsNode.HeaderAdderInterceptor3.intercept_unary_unary"><code class="name flex">
<span>async def <span class="ident">intercept_unary_unary</span></span>(<span>self, continuation, client_call_details, request)</span>
</code></dt>
<dd>
<div class="desc"><p>Intercepts a unary-unary invocation asynchronously.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>continuation</code></strong></dt>
<dd>A coroutine that proceeds with the invocation by
executing the next interceptor in the chain or invoking the
actual RPC on the underlying Channel. It is the interceptor's
responsibility to call it if it decides to move the RPC forward.
The interceptor can use
<code>call = await continuation(client_call_details, request)</code>
to continue with the RPC. <code>continuation</code> returns the call to the
RPC.</dd>
<dt><strong><code>client_call_details</code></strong></dt>
<dd>A ClientCallDetails object describing the
outgoing RPC.</dd>
<dt><strong><code>request</code></strong></dt>
<dd>The request value for the RPC.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An object with the RPC response.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>AioRpcError</code></dt>
<dd>Indicating that the RPC terminated with non-OK status.</dd>
<dt><code>asyncio.CancelledError</code></dt>
<dd>Indicating that the RPC was canceled.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def intercept_unary_unary(self, continuation, client_call_details, request):
    return await self._intercept(continuation, client_call_details, request)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="openagents.OpenAgentsNode.OpenAgentsNode"><code class="flex name class">
<span>class <span class="ident">OpenAgentsNode</span></span>
<span>(</span><span>config: <a title="openagents.NodeConfig.NodeConfig" href="NodeConfig.html#openagents.NodeConfig.NodeConfig">NodeConfig</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>An OpenAgents node that can run jobs.
The node can be configured with the following environment variables:
- NODE_NAME: The name of the node. Defaults to "OpenAgentsNode".
- NODE_ICON: The icon of the node. Defaults to "".
- NODE_VERSION: The version of the node. Defaults to "0.0.1".
- NODE_DESCRIPTION: The description of the node. Defaults to "".
- POOL_ADDRESS: The address of the pool. Defaults to "
- POOL_PORT: The port of the pool. Defaults to 5000.
- POOL_SSL: Whether to use SSL for the pool. Defaults to False.
- NODE_TPS: The ticks per second of the node main loop. Defaults to 10.
- NODE_TOKEN: The token of the node. Defaults to None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OpenAgentsNode:
    &#34;&#34;&#34;
    An OpenAgents node that can run jobs.
    The node can be configured with the following environment variables:
    - NODE_NAME: The name of the node. Defaults to &#34;OpenAgentsNode&#34;.
    - NODE_ICON: The icon of the node. Defaults to &#34;&#34;.
    - NODE_VERSION: The version of the node. Defaults to &#34;0.0.1&#34;.
    - NODE_DESCRIPTION: The description of the node. Defaults to &#34;&#34;.
    - POOL_ADDRESS: The address of the pool. Defaults to &#34;
    - POOL_PORT: The port of the pool. Defaults to 5000.
    - POOL_SSL: Whether to use SSL for the pool. Defaults to False.
    - NODE_TPS: The ticks per second of the node main loop. Defaults to 10.
    - NODE_TOKEN: The token of the node. Defaults to None.
    &#34;&#34;&#34;
  
    def __init__(self, config: NodeConfig):
        self.meta = config.getMeta()
            
        self.nextNodeAnnounce = 0        
        self.channel = None
        self.rpcClient = None
        self.registeredRunners=[]
        self.poolAddress = None
        self.poolPort = None
        self.lockedJobs = []
        self.isLooping = False
        self.logger = None
        self.loopInterval = 100
        
    
        self.nodeName = self.meta[&#34;name&#34;]
        self.nodeIcon =  self.meta[&#34;picture&#34;]
        self.nodeVersion =  self.meta[&#34;version&#34;]
        self.nodeDescription =  self.meta[&#34;description&#34;]

        self.channel = None
        self.rpcClient = None
        self.logger = Logger(self.nodeName,self.nodeVersion)
        self.logger.info(&#34;Starting &#34;+self.nodeName+&#34; v&#34;+self.nodeVersion)

    def getMeta(self):
        return self.meta

    def registerRunner(self, runner:JobRunner) -&gt; None:
        &#34;&#34;&#34;
        Register a runner to the node.
        Args:
            runner (JobRunner): The runner to register.
        &#34;&#34;&#34;
        self.registeredRunners.append({
            &#34;runner&#34;: runner,
            &#34;nextAnnouncementTimestamp&#34;: 0    
        })

    def getLogger(self):
        &#34;&#34;&#34;
        Get the active logger for the node.
        &#34;&#34;&#34;
        return self.logger        

    def _getClient(self): 
        &#34;&#34;&#34;
        Get or create a GRPC client for the node.
        &#34;&#34;&#34;
        if self.channel is None or self.channel._channel.check_connectivity_state(True)  == grpc.ChannelConnectivity.SHUTDOWN:
            if self.channel is not None:
                try:
                    self.getLogger().info(&#34;Closing channel&#34;)
                    self.channel.close()
                except Exception as e:
                    self.getLogger().error(&#34;Error closing channel &#34;+str(e))
            self.getLogger().info(&#34;Connect to &#34;+self.poolAddress+&#34;:&#34;+str(self.poolPort)+&#34; with ssl &#34;+str(self.poolSsl))
            
            options=[
                # 20 MB
                (&#39;grpc.max_send_message_length&#39;, 1024*1024*20),
                (&#39;grpc.max_receive_message_length&#39;, 1024*1024*20)
            ]

            interceptors=None
            nodeToken = os.getenv(&#39;NODE_TOKEN&#39;, None)
            if nodeToken:
                metadata=[
                    (&#34;authorization&#34;, str(nodeToken))
                ]
                if interceptors is None: interceptors=[]
                interceptors.append(HeaderAdderInterceptor0(metadata))
                interceptors.append(HeaderAdderInterceptor1(metadata))
                interceptors.append(HeaderAdderInterceptor2(metadata))
                interceptors.append(HeaderAdderInterceptor3(metadata))
                

            if self.poolSsl:
                self.channel = grpc.aio.secure_channel(self.poolAddress+&#34;:&#34;+str(self.poolPort), grpc.ssl_channel_credentials(),options,interceptors=interceptors)
            else:
                self.channel = grpc.aio.insecure_channel(self.poolAddress+&#34;:&#34;+str(self.poolPort),options,interceptors=interceptors)
            
            self.rpcClient = rpc_pb2_grpc.PoolConnectorStub(self.channel)
            

        return self.rpcClient

    async def _logToJob(self, message:str, jobId:str=None):
        &#34;&#34;&#34;
        Log a message to a job.
        Args:
            message (str): The message to log.
            jobId (str): The ID of the job to log to.
        &#34;&#34;&#34;
        try:
            await self._getClient().logForJob(rpc_pb2.RpcJobLog(jobId=jobId, log=message)) 
        except Exception as e:
            print(&#34;Error logging to job &#34;+str(e))

    def _log(self,message:str, jobId:str=None):
        &#34;&#34;&#34;
        Log a message to the network.
        Args:
            message (str): The message to log.
            jobId (str): The ID of the job to log to.
        &#34;&#34;&#34;
        if jobId: 
            asyncio.create_task(self._logToJob(message, jobId))
    
    async def _acceptJob(self, jobId:str):
        &#34;&#34;&#34;
        Accept a job.
        Args:
            jobId (str): The ID of the job to accept.
        &#34;&#34;&#34;
        await self._getClient().acceptJob(rpc_pb2.RpcAcceptJob(jobId=jobId))

    async def _executePendingJobForRunner(self , runner:JobRunner):
        &#34;&#34;&#34;
        Execute all pending jobs for a runner.
        Args:
            runner (JobRunner): The runner to execute the job.
        &#34;&#34;&#34;
        if len([x for x in self.registeredRunners if x[&#34;runner&#34;]==runner])==0:
            del self.runnerTasks[runner]
            return
        
        try:
            if not runner.initialized:
                runner.initialized=True
                await runner.init(self)
            client = self._getClient()
            jobs=[]
            filter = runner.getFilter()
            self.lockedJobs = [x for x in self.lockedJobs if time.time()-x[1] &lt; 60]
            jobs.extend((await client.getPendingJobs(rpc_pb2.RpcGetPendingJobs(
                filterByRunOn =  filter[&#34;filterByRunOn&#34;] if &#34;filterByRunOn&#34; in filter else None,
                filterByCustomer = filter[&#34;filterByCustomer&#34;] if &#34;filterByCustomer&#34; in filter else None,
                filterByDescription = filter[&#34;filterByDescription&#34;] if &#34;filterByDescription&#34; in filter else None,
                filterById = filter[&#34;filterById&#34;] if &#34;filterById&#34; in filter else None,
                filterByKind  = filter[&#34;filterByKind&#34;] if &#34;filterByKind&#34; in filter else None,
                wait=60000,
                # exclude failed jobs
                excludeId = [x[0] for x in self.lockedJobs]
            ))).jobs)    

            if len(jobs)&gt;0 : self.getLogger().log(str(len(jobs))+&#34; pending jobs for &#34;+runner.__class__.__name__)
            else : self.getLogger().finer(&#34;No pending jobs for &#34;+runner.__class__.__name__)
            
            for job in jobs:              
                wasAccepted=False
                t=time.time()   
                ctx = JobContext(self,runner,job)
                try:
                    client = self._getClient() # Refresh client connection if needed
                    if not await runner.canRun(ctx):
                        await ctx.close()
                        continue
                    self.lockedJobs.append([job.id, time.time()])
                    await self._acceptJob(job.id)
                    wasAccepted = True


                    
                    ctx.getLogger().info(&#34;Job started on node &#34;+self.nodeName)  
                    
                    await runner.preRun(ctx)
                    async def task():
                        try:
                            output=await runner.run(ctx) 
                            await runner.postRun(ctx)                  
                            ctx.getLogger().info(&#34;Job completed in &#34;+str(time.time()-t)+&#34; seconds on node &#34;+self.nodeName, job.id)                
                            await client.completeJob(rpc_pb2.RpcJobOutput(jobId=job.id, output=output))
                        except Exception as e:
                            ctx.getLogger().error(&#34;Job failed in &#34;+str(time.time()-t)+&#34; seconds on node &#34;+self.nodeName+&#34; with error &#34;+str(e), job.id)
                            if wasAccepted:
                                await client.cancelJob(rpc_pb2.RpcCancelJob(jobId=job.id, reason=str(e)))
                            traceback.print_exc()
                        await ctx.close()
                    if not runner.isRunInParallel():
                        await task()
                    else:
                        asyncio.create_task(task())
                except Exception as e:
                    ctx.getLogger().error(&#34;Job failed in &#34;+str(time.time()-t)+&#34; seconds on node &#34;+self.nodeName+&#34; with error &#34;+str(e), job.id)
                    await ctx.close()
                    if wasAccepted:
                        await client.cancelJob(rpc_pb2.RpcCancelJob(jobId=job.id, reason=str(e)))
                    traceback.print_exc()

        except Exception as e:
            traceback.print_exc()
            self.getLogger().error(&#34;Error executing runner &#34;+str(e))
            await asyncio.sleep(5000.0/1000.0)
        self.runnerTasks[runner]=asyncio.create_task(self._executePendingJobForRunner(runner))

 
    runnerTasks={}
    async def _executePendingJob(self ):
        &#34;&#34;&#34;
        Execute all pending jobs for all runners.
        &#34;&#34;&#34;
        for reg in self.registeredRunners:
            try:
                runner = reg[&#34;runner&#34;]
                if not runner in self.runnerTasks:
                    self.runnerTasks[runner]=asyncio.create_task(self._executePendingJobForRunner(runner))
            except Exception as e:
                self.getLogger().log(&#34;Error executing pending job &#34;+str(e), None)


    async def reannounce(self):    
        &#34;&#34;&#34;
        Reannounce the node and all templates.
        &#34;&#34;&#34;
        # Announce node
        try:
            time_ms=int(time.time()*1000)
            if time_ms &gt;= self.nextNodeAnnounce:
                try:
                    client = self._getClient()
                    res=await client.announceNode(rpc_pb2.RpcAnnounceNodeRequest(
                        iconUrl = self.nodeIcon,
                        name = self.nodeName,
                        description = self.nodeDescription,
                    ))
                    self.nextNodeAnnounce = int(time.time()*1000) + res.refreshInterval
                    self.getLogger().log(&#34;Node announced, next announcement in &#34;+str(res.refreshInterval)+&#34; ms&#34;)
                except Exception as e:
                    self.getLogger().error(&#34;Error announcing node &#34;+ str(e), None)
                    self.nextNodeAnnounce = int(time.time()*1000) + 5000

            for reg in self.registeredRunners:
                try:
                    if time_ms &gt;=  reg[&#34;nextAnnouncementTimestamp&#34;]:
                        client = self._getClient()
                        res = await client.announceEventTemplate(rpc_pb2.RpcAnnounceTemplateRequest(
                            meta=json.dumps(reg[&#34;runner&#34;].getMeta()),
                            template=reg[&#34;runner&#34;].getTemplate(),
                            sockets=json.dumps(reg[&#34;runner&#34;].getSockets())
                        ))
                        reg[&#34;nextAnnouncementTimestamp&#34;] = int(time.time()*1000) + res.refreshInterval
                        self.getLogger().log(&#34;Template announced, next announcement in &#34;+str(res.refreshInterval)+&#34; ms&#34;)
                except Exception as e:
                    self.getLogger().error(&#34;Error announcing template &#34;+ str(e), None)
                    reg[&#34;nextAnnouncementTimestamp&#34;] = int(time.time()*1000) + 5000
        except Exception as e:
            self.getLogger().error(&#34;Error reannouncing &#34;+str(e), None)
        await asyncio.sleep(5000.0/1000.0)
        asyncio.create_task(self.reannounce())
  
    async def _loop(self):
        &#34;&#34;&#34;
        The main loop of the node.
        &#34;&#34;&#34;
        promises = [reg[&#34;runner&#34;].loop(self) for reg in self.registeredRunners]
        await asyncio.gather(*promises)
        self.isLooping = False
        await asyncio.sleep(self.loopInterval/1000.0)
        asyncio.create_task(self._loop())
        

    async def _run(self, poolAddress=None, poolPort=None, poolSsl=False):
        &#34;&#34;&#34;
        Internal method to run the node.
        Should not be called, use start() instead.
        &#34;&#34;&#34;
        await asyncio.sleep(5000.0/1000.0)
        self.poolAddress = poolAddress or os.getenv(&#39;POOL_ADDRESS&#39;, &#34;playground.openagents.com&#34;)
        self.poolPort = poolPort or int(os.getenv(&#39;POOL_PORT&#39;, &#34;6021&#34;))
        self.poolSsl = poolSsl or os.getenv(&#39;POOL_SSL&#39;, &#34;true&#34;)== &#34;true&#34;
        self.loopInterval = 1000.0/int(os.getenv(&#39;NODE_TPS&#39;, &#34;10&#34;))

        await self._loop()
        await self.reannounce()
        while True:
            await self._executePendingJob()
            await asyncio.sleep(1000.0/1000.0)
        
    def start(self, poolAddress:str=None, poolPort:str=None):
        &#34;&#34;&#34;
        Start the node in an asyncio event loop.
        Args:
            poolAddress (str): The address of the pool. Defaults to
                the environment variable POOL_ADDRESS.
            poolPort (int): The port of the pool. Defaults to the
                environment variable POOL_PORT.
        &#34;&#34;&#34;
        asyncio.run(self._run(poolAddress, poolPort))</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="openagents.OpenAgentsNode.OpenAgentsNode.runnerTasks"><code class="name">var <span class="ident">runnerTasks</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="openagents.OpenAgentsNode.OpenAgentsNode.getLogger"><code class="name flex">
<span>def <span class="ident">getLogger</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the active logger for the node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getLogger(self):
    &#34;&#34;&#34;
    Get the active logger for the node.
    &#34;&#34;&#34;
    return self.logger        </code></pre>
</details>
</dd>
<dt id="openagents.OpenAgentsNode.OpenAgentsNode.getMeta"><code class="name flex">
<span>def <span class="ident">getMeta</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getMeta(self):
    return self.meta</code></pre>
</details>
</dd>
<dt id="openagents.OpenAgentsNode.OpenAgentsNode.reannounce"><code class="name flex">
<span>async def <span class="ident">reannounce</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reannounce the node and all templates.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def reannounce(self):    
    &#34;&#34;&#34;
    Reannounce the node and all templates.
    &#34;&#34;&#34;
    # Announce node
    try:
        time_ms=int(time.time()*1000)
        if time_ms &gt;= self.nextNodeAnnounce:
            try:
                client = self._getClient()
                res=await client.announceNode(rpc_pb2.RpcAnnounceNodeRequest(
                    iconUrl = self.nodeIcon,
                    name = self.nodeName,
                    description = self.nodeDescription,
                ))
                self.nextNodeAnnounce = int(time.time()*1000) + res.refreshInterval
                self.getLogger().log(&#34;Node announced, next announcement in &#34;+str(res.refreshInterval)+&#34; ms&#34;)
            except Exception as e:
                self.getLogger().error(&#34;Error announcing node &#34;+ str(e), None)
                self.nextNodeAnnounce = int(time.time()*1000) + 5000

        for reg in self.registeredRunners:
            try:
                if time_ms &gt;=  reg[&#34;nextAnnouncementTimestamp&#34;]:
                    client = self._getClient()
                    res = await client.announceEventTemplate(rpc_pb2.RpcAnnounceTemplateRequest(
                        meta=json.dumps(reg[&#34;runner&#34;].getMeta()),
                        template=reg[&#34;runner&#34;].getTemplate(),
                        sockets=json.dumps(reg[&#34;runner&#34;].getSockets())
                    ))
                    reg[&#34;nextAnnouncementTimestamp&#34;] = int(time.time()*1000) + res.refreshInterval
                    self.getLogger().log(&#34;Template announced, next announcement in &#34;+str(res.refreshInterval)+&#34; ms&#34;)
            except Exception as e:
                self.getLogger().error(&#34;Error announcing template &#34;+ str(e), None)
                reg[&#34;nextAnnouncementTimestamp&#34;] = int(time.time()*1000) + 5000
    except Exception as e:
        self.getLogger().error(&#34;Error reannouncing &#34;+str(e), None)
    await asyncio.sleep(5000.0/1000.0)
    asyncio.create_task(self.reannounce())</code></pre>
</details>
</dd>
<dt id="openagents.OpenAgentsNode.OpenAgentsNode.registerRunner"><code class="name flex">
<span>def <span class="ident">registerRunner</span></span>(<span>self, runner: <a title="openagents.JobRunner.JobRunner" href="JobRunner.html#openagents.JobRunner.JobRunner">JobRunner</a>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Register a runner to the node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>runner</code></strong> :&ensp;<code>JobRunner</code></dt>
<dd>The runner to register.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def registerRunner(self, runner:JobRunner) -&gt; None:
    &#34;&#34;&#34;
    Register a runner to the node.
    Args:
        runner (JobRunner): The runner to register.
    &#34;&#34;&#34;
    self.registeredRunners.append({
        &#34;runner&#34;: runner,
        &#34;nextAnnouncementTimestamp&#34;: 0    
    })</code></pre>
</details>
</dd>
<dt id="openagents.OpenAgentsNode.OpenAgentsNode.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self, poolAddress: str = None, poolPort: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Start the node in an asyncio event loop.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>poolAddress</code></strong> :&ensp;<code>str</code></dt>
<dd>The address of the pool. Defaults to
the environment variable POOL_ADDRESS.</dd>
<dt><strong><code>poolPort</code></strong> :&ensp;<code>int</code></dt>
<dd>The port of the pool. Defaults to the
environment variable POOL_PORT.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self, poolAddress:str=None, poolPort:str=None):
    &#34;&#34;&#34;
    Start the node in an asyncio event loop.
    Args:
        poolAddress (str): The address of the pool. Defaults to
            the environment variable POOL_ADDRESS.
        poolPort (int): The port of the pool. Defaults to the
            environment variable POOL_PORT.
    &#34;&#34;&#34;
    asyncio.run(self._run(poolAddress, poolPort))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="openagents" href="index.html">openagents</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="openagents.OpenAgentsNode.HeaderAdderInterceptor" href="#openagents.OpenAgentsNode.HeaderAdderInterceptor">HeaderAdderInterceptor</a></code></h4>
</li>
<li>
<h4><code><a title="openagents.OpenAgentsNode.HeaderAdderInterceptor0" href="#openagents.OpenAgentsNode.HeaderAdderInterceptor0">HeaderAdderInterceptor0</a></code></h4>
<ul class="">
<li><code><a title="openagents.OpenAgentsNode.HeaderAdderInterceptor0.intercept_unary_stream" href="#openagents.OpenAgentsNode.HeaderAdderInterceptor0.intercept_unary_stream">intercept_unary_stream</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openagents.OpenAgentsNode.HeaderAdderInterceptor1" href="#openagents.OpenAgentsNode.HeaderAdderInterceptor1">HeaderAdderInterceptor1</a></code></h4>
<ul class="">
<li><code><a title="openagents.OpenAgentsNode.HeaderAdderInterceptor1.intercept_stream_unary" href="#openagents.OpenAgentsNode.HeaderAdderInterceptor1.intercept_stream_unary">intercept_stream_unary</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openagents.OpenAgentsNode.HeaderAdderInterceptor2" href="#openagents.OpenAgentsNode.HeaderAdderInterceptor2">HeaderAdderInterceptor2</a></code></h4>
<ul class="">
<li><code><a title="openagents.OpenAgentsNode.HeaderAdderInterceptor2.intercept_stream_stream" href="#openagents.OpenAgentsNode.HeaderAdderInterceptor2.intercept_stream_stream">intercept_stream_stream</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openagents.OpenAgentsNode.HeaderAdderInterceptor3" href="#openagents.OpenAgentsNode.HeaderAdderInterceptor3">HeaderAdderInterceptor3</a></code></h4>
<ul class="">
<li><code><a title="openagents.OpenAgentsNode.HeaderAdderInterceptor3.intercept_unary_unary" href="#openagents.OpenAgentsNode.HeaderAdderInterceptor3.intercept_unary_unary">intercept_unary_unary</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openagents.OpenAgentsNode.OpenAgentsNode" href="#openagents.OpenAgentsNode.OpenAgentsNode">OpenAgentsNode</a></code></h4>
<ul class="two-column">
<li><code><a title="openagents.OpenAgentsNode.OpenAgentsNode.getLogger" href="#openagents.OpenAgentsNode.OpenAgentsNode.getLogger">getLogger</a></code></li>
<li><code><a title="openagents.OpenAgentsNode.OpenAgentsNode.getMeta" href="#openagents.OpenAgentsNode.OpenAgentsNode.getMeta">getMeta</a></code></li>
<li><code><a title="openagents.OpenAgentsNode.OpenAgentsNode.reannounce" href="#openagents.OpenAgentsNode.OpenAgentsNode.reannounce">reannounce</a></code></li>
<li><code><a title="openagents.OpenAgentsNode.OpenAgentsNode.registerRunner" href="#openagents.OpenAgentsNode.OpenAgentsNode.registerRunner">registerRunner</a></code></li>
<li><code><a title="openagents.OpenAgentsNode.OpenAgentsNode.runnerTasks" href="#openagents.OpenAgentsNode.OpenAgentsNode.runnerTasks">runnerTasks</a></code></li>
<li><code><a title="openagents.OpenAgentsNode.OpenAgentsNode.start" href="#openagents.OpenAgentsNode.OpenAgentsNode.start">start</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>